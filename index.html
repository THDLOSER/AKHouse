<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æƒ³ä½ ç‰†ï¼ˆæ‰£åˆ†æ‰“æ‰“ï¼‹å§“åç•™è¨€ï¼‹ğŸ’¯ï¼‰</title>
<style>
  :root{
    --bg:#ffffff; --fg:#111111; --sub:#555; --card:#ffffff; --br:#e6e6e6;
    --btn:#fafafa; --btn-br:#dddddd;
    --c-think:#ff6aa2; --c-hug:#6aa8ff; --c-kiss:#7bd88f; --c-lean:#f7c84b; --c-rub:#c18cff; --c-tap:#ff9b6a;
  }
  [data-theme="dark"]{
    --bg:#0f1115; --fg:#ffffff; --sub:#c7c7c7; --card:#141820; --br:#2a2f3a;
    --btn:#1a1f29; --btn-br:#2a2f3a;
    --c-think:#ff84b4; --c-hug:#8bbbff; --c-kiss:#9be3ab; --c-lean:#ffd76a; --c-rub:#d2a6ff; --c-tap:#ffb489;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,"Noto Sans TC",Segoe UI,Roboto}
  header{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--br)}
  header .right{display:flex;gap:8px;align-items:center}
  .wrap{padding:14px 14px 28px;display:flex;flex-direction:column;gap:12px}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;max-width:720px;margin:0 auto;width:100%}
  @media(min-width:640px){.grid{grid-template-columns:repeat(3,1fr)}}
  button{
    padding:14px 12px;border:1px solid var(--btn-br);border-radius:10px;background:var(--btn);cursor:pointer;
    font-size:16px;font-weight:700;color:var(--fg)
  }
  .row{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:980px){.row{grid-template-columns:1.2fr .8fr}}
  .canvas-wrap{border:1px dashed var(--br);border-radius:12px;padding:10px;background:var(--card)}
  #wall{width:100%;height:52vh;display:block}
  .legend{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin:8px 0 0}
  .chip{display:inline-flex;gap:6px;align-items:center;border:1px solid var(--br);border-radius:999px;padding:6px 10px;background:var(--card);color:var(--fg)}
  .dot{width:10px;height:10px;border-radius:50%}
  .card{background:var(--card);border:1px solid var(--br);border-radius:12px;padding:12px}
  .muted{color:var(--sub)}
  table{width:100%;border-collapse:collapse;color:var(--fg)}
  th,td{border-bottom:1px solid var(--br);padding:8px 6px;text-align:right}
  th:first-child,td:first-child{text-align:left}
  .kpi{display:flex;gap:12px;flex-wrap:wrap}
  .kpi .box{background:var(--card);border:1px solid var(--br);border-radius:10px;padding:10px 12px;min-width:120px}
  .ghost{opacity:.7}
  input,textarea,select{background:var(--card);color:var(--fg);border:1px solid var(--br);border-radius:10px;padding:10px}
  textarea{width:100%;box-sizing:border-box;resize:vertical}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;font-size:12px;margin-right:6px;border:1px solid var(--br);background:var(--card);color:var(--fg)}
  .badge.think{border-color:var(--c-think)}
  .badge.hug{border-color:var(--c-hug)}
  .badge.kiss{border-color:var(--c-kiss)}
  .badge.lean{border-color:var(--c-lean)}
  .badge.rub{border-color:var(--c-rub)}
  .badge.tap{border-color:var(--c-tap)}
</style>
</head>
<body>
<header>
  <div><strong>æƒ³ä½ ç‰†</strong> <span class="muted">ï¼ˆA&K Houseï¼‰</span></div>
  <div class="right">
    <button id="btnTheme" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ™/â˜€ï¸</button>
    <button id="btnResetGate" title="é‡æ–°é©—è­‰">ğŸ”’ é‡æ–°é©—è­‰</button>
  </div>
</header>

<div class="wrap">

  <!-- å•ç­”è§£é– -->
  <div id="gate" class="card">
    <div style="font-weight:800;margin-bottom:6px">æˆ‘å€‘ç´„å®šå¥½å¹¾æ­²ï¼Ÿ</div>
    <div class="toolbar">
      <input id="inpAge" type="text" inputmode="numeric" placeholder="è«‹è¼¸å…¥æ•¸å­—" />
      <button id="btnGate">è§£é–</button>
    </div>
    <div id="gateMsg" class="muted" style="margin-top:6px"></div>
  </div>

  <!-- ä¸»åŠŸèƒ½ -->
  <div id="main" style="display:none">
    <div class="grid" style="margin-bottom:6px">
      <button class="action-btn" data-key="think">ğŸ©· æƒ³ä½ </button>
      <button class="action-btn" data-key="hug">ğŸ¤— æƒ³æŠ±æŠ±</button>
      <button class="action-btn" data-key="kiss">ğŸ˜˜ è¦ªè¦ª</button>
      <button class="action-btn" data-key="lean">ğŸ«´ é ä¸€ä¸‹</button>
      <button class="action-btn" data-key="rub">ğŸ¾ æ“æ“</button>
      <button class="action-btn" data-key="tap">ğŸ‘Š æ‰“æ‰“ï¼ˆæ‰£ï¼‰</button>
    </div>

    <div class="row">
      <div class="canvas-wrap">
        <canvas id="wall"></canvas>
        <div class="legend">
          <span class="chip"><span class="dot" style="background:var(--c-think)"></span>æƒ³ä½ </span>
          <span class="chip"><span class="dot" style="background:var(--c-hug)"></span>æŠ±æŠ±</span>
          <span class="chip"><span class="dot" style="background:var(--c-kiss)"></span>è¦ªè¦ª</span>
          <span class="chip"><span class="dot" style="background:var(--c-lean)"></span>é ä¸€ä¸‹</span>
          <span class="chip"><span class="dot" style="background:var(--c-rub)"></span>æ“æ“</span>
          <span class="chip"><span class="dot" style="background:var(--c-tap)"></span>æ‰“æ‰“ï¼ˆæ‰£ï¼‰</span>
          <span class="muted" style="margin-left:6px">ï¼Šæ¯ 100 ä»¥ ğŸ’¯ è¡¨ç¤ºï¼Œæ¯ 50 ä»¥ âœ¨ è¡¨ç¤º </span>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:800;margin-bottom:8px">å€’æ•¸</div>
        <div class="kpi">
          <div class="box">
            <div class="muted">è·ä¸Šæ¬¡å…Œç¾å·²é</div>
            <div id="sinceTxt" style="font-size:18px;font-weight:800">--</div>
          </div>
          <div class="box">
            <div class="muted">ç›®å‰ç´¯è¨ˆå·²å…Œç¾ï¼ˆå…¨éƒ¨æœŸé–“ï¼‰</div>
            <div id="sumAllTxt" style="font-size:14px">
              æƒ³ä½  <b id="sumThink">0</b>ã€æŠ±æŠ± <b id="sumHug">0</b>ã€è¦ªè¦ª <b id="sumKiss">0</b>ã€é ä¸€ä¸‹ <b id="sumLean">0</b>ã€æ“æ“ <b id="sumRub">0</b>ã€æ‰“æ‰“(æ‰£) <b id="sumTap">0</b>
            </div>
          </div>
        </div>

        <div class="toolbar" style="margin-top:10px">
          <button id="btnRedeemOpen">ğŸ å…¨éƒ¨å…Œç¾</button>
          <button id="btnPostNoteOpen">ğŸ“ åªæ˜¯å–®ç¨ç•™è¨€</button>
        </div>

        <div class="card" style="margin-top:10px">
          <div style="font-weight:800;margin-bottom:6px">å…Œç¾çµ±è¨ˆè¡¨ï¼ˆå¯ç¯©é¸ï¼‰</div>
          <div class="toolbar" style="margin-bottom:6px">
            <label>å¹´ <select id="selYear"></select></label>
            <label>æœˆ <select id="selMonth"><option value="">å…¨éƒ¨</option></select></label>
            <button id="btnExportCsv">â¬‡ï¸ åŒ¯å‡ºCSV</button>
            <button id="btnExportZip">ğŸ“¦ æ‰“åŒ…åŒ¯å‡ºZIP</button>
            <span class="muted">æœ¬æœŸé–“åˆè¨ˆï¼šæƒ³ä½  <b id="sumPThink">0</b>ã€æŠ±æŠ± <b id="sumPHug">0</b>ã€è¦ªè¦ª <b id="sumPKiss">0</b>ã€é ä¸€ä¸‹ <b id="sumPLean">0</b>ã€æ“æ“ <b id="sumPRub">0</b>ã€æ‰“æ‰“(æ‰£) <b id="sumPTap">0</b></span>
          </div>
          <div class="table-wrap">
            <table>
              <thead><tr><th>æ—¥æœŸ</th><th>æƒ³ä½ </th><th>æŠ±æŠ±</th><th>è¦ªè¦ª</th><th>é ä¸€ä¸‹</th><th>æ“æ“</th><th>æ‰“æ‰“(æ‰£)</th><th>æ‰£åˆ°</th></tr></thead>
              <tbody id="tbStats"><tr><td colspan="8" class="muted">è®€å–ä¸­â€¦</td></tr></tbody>
            </table>
          </div>
        </div>

        <div class="card" style="margin-top:10px">
          <div style="font-weight:800;margin-bottom:6px">è¿‘æœŸå…Œç¾å°æ•…äº‹</div>
          <div class="toolbar" style="margin-bottom:6px">
            <label>æ’åº
              <select id="selStorySort">
                <option value="ts_desc">æ™‚é–“ï¼šæ–° â†’ èˆŠ</option>
                <option value="ts_asc">æ™‚é–“ï¼šèˆŠ â†’ æ–°</option>
                <option value="total_desc">åˆè¨ˆï¼šå¤š â†’ å°‘</option>
                <option value="rub_desc">æ“æ“ï¼šå¤š â†’ å°‘</option>
              </select>
            </label>
            <button id="btnColorCfg" class="ghost">ğŸ¨ é¡è‰²è¨­å®š</button>
          </div>
          <div id="storiesList" class="muted">å°šç„¡ç´€éŒ„</div>
          <div style="margin-top:8px"><button id="btnMoreStories" class="ghost">è¼‰å…¥æ›´å¤šå°æ•…äº‹</button></div>
        </div>

        <div class="card" style="margin-top:10px">
          <div style="font-weight:800;margin-bottom:6px">åªæ˜¯å–®ç¨ç•™è¨€ï¼ˆä¸å½±éŸ¿è¨ˆæ•¸ï¼‰</div>

          <div class="toolbar" style="margin-bottom:6px">
            <button id="btnExportNotesCsv">â¬‡ï¸ åŒ¯å‡ºç•™è¨€CSV</button>
            <span class="muted">ï¼ˆä¾ä¸Šæ–¹å¹´ï¼æœˆç¯©é¸ï¼‰</span>
          </div>

          <div id="notesList" class="muted">å°šç„¡ç•™è¨€</div>
          <div style="margin-top:8px"><button id="btnMoreNotes" class="ghost">è¼‰å…¥æ›´å¤šç•™è¨€</button></div>
        </div>

      </div>
    </div>
  </div>
</div>

<audio id="meowSound" src="meow.mp3" preload="auto"></audio>

<!-- éŒ¯èª¤é¢æ¿ï¼ä¸»é¡Œåˆ‡æ›ï¼è§£é– -->
<script>
  function showErrorOverlay(err){
    try{
      const box = document.createElement('div');
      box.style.position='fixed'; box.style.left='10px'; box.style.right='10px';
      box.style.bottom='10px'; box.style.zIndex='9999';
      box.style.padding='10px 12px'; box.style.border='1px solid var(--br)';
      box.style.borderRadius='10px'; box.style.background='var(--card)';
      box.style.color='var(--fg)'; box.style.fontSize='12px';
      box.style.maxHeight='40vh'; box.style.overflow='auto';
      box.innerHTML = `<b>è¼‰å…¥æ™‚ç™¼ç”ŸéŒ¯èª¤</b><br><pre style="white-space:pre-wrap">${(err && (err.stack||err.message||String(err)))}</pre>`;
      document.body.appendChild(box);
    }catch{}
  }
  window.addEventListener('error', e => showErrorOverlay(e.error || e.message));
  window.addEventListener('unhandledrejection', e => showErrorOverlay(e.reason || e));

  (function(){ // ä¸»é¡Œåˆ‡æ›
    const root = document.documentElement;
    const btnTheme = document.getElementById('btnTheme');
    function applyTheme(v){
      root.setAttribute('data-theme', v==='dark' ? 'dark' : 'light');
      localStorage.setItem('theme', v);
      if (typeof fitCanvas === 'function') fitCanvas();
    }
    const saved = localStorage.getItem('theme');
    if (saved) applyTheme(saved);
    else applyTheme( window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light' );
    btnTheme?.addEventListener('click', ()=> {
      const next = root.getAttribute('data-theme')==='dark' ? 'light' : 'dark';
      applyTheme(next);
    });
  })();

  (function(){ // å•ç­”è§£é–ï¼ˆ65ï¼‰â€” æ——æ¨™å»¶å¾Œåˆå§‹åŒ–
    const GATE_ANSWER = 65, GATE_TTL_DAYS = 7;
    const gate = document.getElementById('gate'), main = document.getElementById('main');
    const inpAge = document.getElementById('inpAge'), btnGate = document.getElementById('btnGate');
    const gateMsg = document.getElementById('gateMsg'), btnResetGate = document.getElementById('btnResetGate');
    function toHalfWidthNum(s){ return (s||'').replace(/[ï¼-ï¼™]/g, d => String.fromCharCode(d.charCodeAt(0)-0xFEE0)); }
    function normAge(v){ const s = toHalfWidthNum(String(v||'')).replace(/\s+/g,'').replace(/[^\d]/g,''); const n = parseInt(s,10); return Number.isFinite(n)?n:NaN; }
    function openGate(){ gate.style.display='block'; main.style.display='none'; }
    function openMain(){ gate.style.display='none'; main.style.display='block'; }
    function gateOk(){ const ok = localStorage.getItem('gate-ok')==='1'; if(!ok) return false; if(GATE_TTL_DAYS<=0) return false; const ts=parseInt(localStorage.getItem('gate-ok-ts')||'0',10); return (Date.now()-ts)<GATE_TTL_DAYS*86400000; }
    function setGateOk(){ localStorage.setItem('gate-ok','1'); localStorage.setItem('gate-ok-ts', String(Date.now())); }
    btnResetGate.onclick = ()=>{ localStorage.removeItem('gate-ok'); localStorage.removeItem('gate-ok-ts'); openGate(); };

    if (new URLSearchParams(location.search).get('reset')==='1'){
      localStorage.removeItem('gate-ok'); localStorage.removeItem('gate-ok-ts');
    }
    if (gateOk()){ openMain(); localStorage.setItem('app-should-init','1'); } else { openGate(); }

    btnGate.onclick = ()=>{
      const n=normAge(inpAge.value);
      if(n===GATE_ANSWER){
        setGateOk(); gateMsg.textContent=''; openMain();
        localStorage.setItem('app-should-init','1');
        if (typeof window.__afterUnlock === 'function') window.__afterUnlock();
      }else{
        gateMsg.textContent='ç­”éŒ¯å›‰ï½å†è©¦è©¦ï¼ˆæç¤ºï¼š65ï¼‰';
      }
    };
    inpAge.addEventListener('keydown', e=>{ if(e.key==='Enter') btnGate.click(); });
  })();
</script>

<!-- è§£é–å¾Œæ‰è¼‰å…¥ Firebase + ä¸» App -->
<script>
  window.__afterUnlock = async function(){
    try{
	const firebaseConfig = {
	  apiKey: "AIzaSyAiJTyJGBZIOQW9KAmBUNbxdBFJFr2ABuc",
	  authDomain: "aether-karen-board.firebaseapp.com",
	  projectId: "aether-karen-board",
	  storageBucket: "aether-karen-board.firebasestorage.app",
	  messagingSenderId: "907550532349",
	  appId: "1:907550532349:web:c6bf67c8b86d44e3841494",
	  measurementId: "G-Y91SWR8FBQ"
	};

      const [{ initializeApp }, { getAuth, signInAnonymously }, 
             { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, increment,
               serverTimestamp, collection, addDoc, getDocs, query, orderBy, limit, startAfter }] =
        await Promise.all([
          import('https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js'),
          import('https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js'),
          import('https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js')
        ]);

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      try { await signInAnonymously(auth); } 
      catch(e){ showErrorOverlay('åŒ¿åç™»å…¥å¤±æ•—ï¼šè«‹åœ¨ Authentication å•Ÿç”¨ Anonymous\n'+(e && (e.message||e))); }

      function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
      function setCssVar(k,v){ document.documentElement.style.setProperty(k, v); }
      function tinyHex(s){ const x=(s||'').trim(); if(/^#[0-9a-fA-F]{6}$/.test(x)) return x; if(/^#[0-9a-fA-F]{3}$/.test(x)) return '#'+x[1]+x[1]+x[2]+x[2]+x[3]+x[3]; return '#000000'; }
      function readColors(){ return {
        think: cssVar('--c-think')||'#ff6aa2', hug: cssVar('--c-hug')||'#6aa8ff',
        kiss: cssVar('--c-kiss')||'#7bd88f',  lean: cssVar('--c-lean')||'#f7c84b', rub: cssVar('--c-rub')||'#c18cff', tap: cssVar('--c-tap')||'#ff9b6a'
      }; }
      let COLORS = readColors();

      const canvas = document.getElementById('wall');
      const ctx = canvas.getContext('2d', { alpha:true });
      function fitCanvas(){
        const ratio = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width * ratio);
        canvas.height= Math.floor(rect.height * ratio);
        ctx.setTransform(ratio,0,0,ratio,0,0);
        drawAll(lastCounts);
      }

      /* ğŸ’¯ + æ­£å­— çš„ç•«æ³• */
      function drawTallies(startX, startY, color, count, scale = 1){
		  const spacingX = 40 * scale, spacingY = 38 * scale;
		  const rect = canvas.getBoundingClientRect();
		  const usable = Math.max(0, rect.width - startX - 20);
		  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

		  let x = startX, y = startY;

		  // ğŸ’¯: æ¯ 100
		  const hundreds = Math.floor((count || 0) / 100);
		  let rem100   = (count || 0) % 100;

		  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
						  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

		  if (hundreds > 0){
			const oldFill = ctx.fillStyle, oldFont = ctx.font;
			ctx.fillStyle = fgColor;
			ctx.font = `bold ${24 * scale}px system-ui`;
			for (let i = 0; i < hundreds; i++){
			  ctx.fillText('ğŸ’¯', x, y + 24 * scale);
			  x += spacingX;
			  if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
			}
			ctx.fillStyle = oldFill; ctx.font = oldFont;
		  }

		  // âœ¨: æ¯ 50
		  const fifties = Math.floor(rem100 / 50);
		  let rem50 = rem100 % 50;

		  if (fifties > 0){
			const oldFill = ctx.fillStyle, oldFont = ctx.font;
			ctx.fillStyle = fgColor;
			ctx.font = `bold ${24 * scale}px system-ui`;
			for (let i = 0; i < fifties; i++){
			  ctx.fillText('âœ¨', x, y + 24 * scale);
			  x += spacingX;
			  if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
			}
			ctx.fillStyle = oldFill; ctx.font = oldFont;
		  }

		  // æ­£å­—è¨ˆç®—
		  const groups = Math.floor(rem50 / 5);
		  const remain = rem50 % 5;

		  function drawGroup(x, y, color, scale = 1){
			const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
			ctx.strokeStyle = color; ctx.lineWidth = 2;
			for(let i=0;i<4;i++){
			  const xi = x + i * gap + 2 * i;
			  ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
			}
			ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
		  }

		  for (let i = 0; i < groups; i++){
			drawGroup(x, y, color, scale);
			x += spacingX;
			if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
		  }

		  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
		  if (remain > 0){
			const top = y, bottom = y + 28 * scale, gap = 6 * scale;
			ctx.strokeStyle = color; ctx.lineWidth = 2;
			for (let i = 0; i < remain; i++){
			  const xi = x + i * gap + 2 * i;
			  ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
			}
		  }
		}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
	  function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
	  function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
	  function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
	  function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
	  function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
	  function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}
      function drawTallies(startX, startY, color, count, scale = 1){
  const spacingX = 40 * scale, spacingY = 38 * scale;
  const rect = canvas.getBoundingClientRect();
  const usable = Math.max(0, rect.width - startX - 20);
  const maxPerRow = Math.max(1, Math.floor(usable / spacingX));

  let x = startX, y = startY;

  // ğŸ’¯: æ¯ 100
  const hundreds = Math.floor((count || 0) / 100);
  let rem100   = (count || 0) % 100;

  const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                  || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');

  if (hundreds > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < hundreds; i++){
      ctx.fillText('ğŸ’¯', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // âœ¨: æ¯ 50
  const fifties = Math.floor(rem100 / 50);
  let rem50 = rem100 % 50;

  if (fifties > 0){
    const oldFill = ctx.fillStyle, oldFont = ctx.font;
    ctx.fillStyle = fgColor;
    ctx.font = `bold ${24 * scale}px system-ui`;
    for (let i = 0; i < fifties; i++){
      ctx.fillText('âœ¨', x, y + 24 * scale);
      x += spacingX;
      if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
    }
    ctx.fillStyle = oldFill; ctx.font = oldFont;
  }

  // æ­£å­—è¨ˆç®—
  const groups = Math.floor(rem50 / 5);
  const remain = rem50 % 5;

  function drawGroup(x, y, color, scale = 1){
    const h = 28 * scale, gap = 6 * scale, top = y, bottom = y + h;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(x - 2, bottom - 2); ctx.lineTo(x + gap * 3 + 6, top + 2); ctx.stroke();
  }

  for (let i = 0; i < groups; i++){
    drawGroup(x, y, color, scale);
    x += spacingX;
    if ((i + 1) % maxPerRow === 0){ x = startX; y += spacingY; }
  }

  // å‰©ä¸‹ 1~4 æ ¹ç›´ç·š
  if (remain > 0){
    const top = y, bottom = y + 28 * scale, gap = 6 * scale;
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    for (let i = 0; i < remain; i++){
      const xi = x + i * gap + 2 * i;
      ctx.beginPath(); ctx.moveTo(xi, top); ctx.lineTo(xi, bottom); ctx.stroke();
    }
  }
}

      function layout(){
        const rect = canvas.getBoundingClientRect();
        const margin=18, colGap=rect.width/3, rowGap=rect.height/2.2;
        return {
          think:{x:margin, y:margin}, 
          hug:{x:colGap+margin/2, y:margin}, 
          kiss:{x:colGap*2+margin/2, y:margin},
          lean:{x:margin, y:rowGap},  
          rub:{x:colGap+margin/2, y:rowGap},
          tap:{x:colGap*2+margin/2, y:rowGap}
        };
      }
      let lastCounts={think:0,hug:0,kiss:0,lean:0,rub:0,tap:0};
      function drawAll(c){
        if(!canvas.width || !canvas.height) return;
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0,0,rect.width,rect.height);
        const fgColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()
                        || (document.documentElement.getAttribute('data-theme')==='dark' ? '#ffffff' : '#333333');
        ctx.fillStyle = fgColor;
        ctx.font = "bold 14px system-ui";
        const pos = layout();
        ctx.fillText(`æƒ³ä½  (${c.think||0})`, pos.think.x, pos.think.y-6);
        ctx.fillText(`æƒ³æŠ±æŠ± (${c.hug||0})`, pos.hug.x, pos.hug.y-6);
        ctx.fillText(`è¦ªè¦ª (${c.kiss||0})`, pos.kiss.x, pos.kiss.y-6);
        ctx.fillText(`é ä¸€ä¸‹ (${c.lean||0})`, pos.lean.x, pos.lean.y-6);
        ctx.fillText(`æ“æ“ (${c.rub||0})`, pos.rub.x, pos.rub.y-6);
        ctx.fillText(`æ‰“æ‰“(æ‰£) (${c.tap||0})`,  pos.tap.x,  pos.tap.y-6);
        const s=1;
        drawTallies(pos.think.x,pos.think.y,COLORS.think,c.think||0,s);
        drawTallies(pos.hug.x,  pos.hug.y, COLORS.hug,  c.hug||0, s);
        drawTallies(pos.kiss.x, pos.kiss.y, COLORS.kiss, c.kiss||0, s);
        drawTallies(pos.lean.x, pos.lean.y, COLORS.lean, c.lean||0, s);
        drawTallies(pos.rub.x,  pos.rub.y, COLORS.rub,  c.rub||0, s);
        drawTallies(pos.tap.x,  pos.tap.y, COLORS.tap,  c.tap||0, s);
      }
      window.addEventListener('resize', fitCanvas);

      /* ç‰†é¢è³‡æ–™ */
      const countsRef = doc(db, 'tally-wall', 'global');
      async function ensureCountsDoc(){
        const s = await getDoc(countsRef);
        if (!s.exists()){
          await setDoc(countsRef, { think:0, hug:0, kiss:0, lean:0, rub:0, tap:0, createdAt: Date.now() });
        } else {
          const d = s.data()||{};
          if (typeof d.tap !== 'number'){
            await setDoc(countsRef, { tap: 0 }, { merge:true });
          }
        }
      }
      onSnapshot(countsRef, (snap)=>{
        const d = snap.data()||{};
        lastCounts = { think:d.think||0, hug:d.hug||0, kiss:d.kiss||0, lean:d.lean||0, rub:d.rub||0, tap:d.tap||0 };
        fitCanvas();
      });

      /* é»æ“ŠåŠ é»æ•¸ï¼‹å–µå–µï¼ˆæ‰“æ‰“=ç´¯ç©æ‰£åˆ†ï¼‰ */
      const meow = document.getElementById('meowSound');
      document.querySelectorAll('.action-btn').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          try{
            await ensureCountsDoc();
            await updateDoc(countsRef, { [btn.dataset.key]: increment(1) });
            if (meow){ meow.currentTime=0; meow.play().catch(()=>{}); }
          }catch(e){
            try{ await ensureCountsDoc(); await updateDoc(countsRef, { [btn.dataset.key]: increment(1) }); }
            catch(err){ showErrorOverlay(err); }
          }
        });
      });

      /* å…Œç¾ï¼ˆå…¨éƒ¨å…Œç¾ï¼‹å°æ•…äº‹ï¼‹æ‰“æ‰“æ‰£åˆ°èª°ï¼‰ */
      const btnRedeemOpen = document.getElementById('btnRedeemOpen');
      function showDialog(innerHTML, binder){
        const dlg = document.createElement('dialog');
        dlg.style.background='var(--card)'; dlg.style.color='var(--fg)';
        dlg.style.border='1px solid var(--br)'; dlg.style.borderRadius='12px';
        dlg.style.padding='14px'; dlg.innerHTML = innerHTML;
        document.body.appendChild(dlg);
        try{ dlg.showModal(); }catch{ dlg.setAttribute('open','open'); }
        binder?.(dlg); return dlg;
      }
      function closeDialog(dlg){ if(!dlg) return; if (typeof dlg.close==='function'){ try{ dlg.close(); }catch{} } dlg.remove(); }

      btnRedeemOpen.onclick = async ()=>{
        await ensureCountsDoc(); const s = await getDoc(countsRef); const c = s.data()||{};
        const html = `
          <div style="font-weight:800;margin-bottom:8px">ç¢ºèªå…Œç¾</div>
          <div class="muted" style="margin-bottom:6px">æœƒæŠŠç‰†é¢ç›®å‰æ•¸é‡å…¨éƒ¨å…Œç¾ä¸¦æ­¸é›¶ã€‚è‹¥æœ‰ã€Œæ‰“æ‰“(æ‰£)ã€ï¼Œå¯é¸æ“‡è¦æ‰£åˆ°å“ªä¸€é …ï¼š</div>
          <div style="margin-bottom:8px;line-height:1.8">
            æƒ³ä½  <b>${c.think||0}</b>ã€æŠ±æŠ± <b>${c.hug||0}</b>ã€è¦ªè¦ª <b>${c.kiss||0}</b>ã€
            é ä¸€ä¸‹ <b>${c.lean||0}</b>ã€æ“æ“ <b>${c.rub||0}</b>ã€<span class="muted">æ‰“æ‰“(æ‰£) <b>${c.tap||0}</b></span>
          </div>
          <label>æ‰“æ‰“è¦æ‰£åˆ°ï¼š
            <select id="tapTarget">
              <option value="think">æƒ³ä½ </option>
              <option value="hug">æŠ±æŠ±</option>
              <option value="kiss">è¦ªè¦ª</option>
              <option value="lean">é ä¸€ä¸‹</option>
              <option value="rub">æ“æ“</option>
            </select>
          </label>
          <div id="preview" class="muted" style="margin-top:6px"></div>
          <label style="display:block;margin-top:8px">å°æ•…äº‹ï¼ˆé¸å¡«ï¼‰
            <textarea id="rStory" rows="4" placeholder="ä»Šå¤©æˆ‘å€‘æ€éº¼å…Œç¾çš„ï¼Ÿ"></textarea>
          </label>
          <div class="toolbar" style="margin-top:10px;justify-content:flex-end">
            <button id="btnRedeemConfirm">ç¢ºèªå…Œç¾</button>
            <button id="btnRedeemCancel">å–æ¶ˆ</button>
          </div>`;
        const dlg = showDialog(html, (d)=>{
          const sel = d.querySelector('#tapTarget');
          const preview = d.querySelector('#preview');
          function renderPreview(){
            const t = (c.tap||0)>>>0, target = sel.value;
            const base = { think:c.think||0, hug:c.hug||0, kiss:c.kiss||0, lean:c.lean||0, rub:c.rub||0 };
            if (t>0) base[target] = Math.max(0, base[target]-t);
            preview.textContent = `å…Œç¾å¾Œå¯¦å¾—ï¼šæƒ³ä½  ${base.think}ã€æŠ±æŠ± ${base.hug}ã€è¦ªè¦ª ${base.kiss}ã€é ä¸€ä¸‹ ${base.lean}ã€æ“æ“ ${base.rub}` + ( (c.tap||0)>0 ? `ï¼ˆæ‰“æ‰“æ‰£ ${t} â†’ æ‰£åˆ°ã€Œ${sel.options[sel.selectedIndex].text}ã€ï¼‰` : '' );
          }
          renderPreview();
          sel.onchange = renderPreview;

          d.querySelector('#btnRedeemCancel').onclick = ()=> closeDialog(d);
          d.querySelector('#btnRedeemConfirm').onclick = async ()=>{
            const okBtn = d.querySelector('#btnRedeemConfirm');
            okBtn.disabled=true; okBtn.textContent='è™•ç†ä¸­â€¦';
            try{
              const snap = await getDoc(countsRef);
              const cc = snap.data()||{think:0,hug:0,kiss:0,lean:0,rub:0,tap:0};
              const tapTarget = sel.value;
              const tap = (cc.tap||0)>>>0;
              const applied = { think:cc.think||0, hug:cc.hug||0, kiss:cc.kiss||0, lean:cc.lean||0, rub:cc.rub||0 };
              if (tap>0) applied[tapTarget] = Math.max(0, (applied[tapTarget]||0) - tap);

              const t = new Date();
              const dateId = `${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,'0')}-${String(t.getDate()).padStart(2,'0')}`;
              const story = (d.querySelector('#rStory').value||'').trim();

              await addDoc(collection(db,'redeems'), {
                date: dateId,
                think: applied.think, hug: applied.hug, kiss: applied.kiss, lean: applied.lean, rub: applied.rub,
                tap: tap, tapTarget,
                story, ts: serverTimestamp()
              });

              await setDoc(countsRef, { think:0, hug:0, kiss:0, lean:0, rub:0, tap:0 }, { merge:true });
              await setDoc(doc(db,'last-redeem','time'), { ts: serverTimestamp() });

              closeDialog(d);
              loadSince(); loadSumAll(); loadStatsTable(); loadStories(true);
            }catch(err){ showErrorOverlay(err); okBtn.disabled=false; okBtn.textContent='ç¢ºèªå…Œç¾'; }
          };
        });
      };

      /* å€’æ•¸ */
      const sinceTxt = document.getElementById('sinceTxt');
      async function loadSince(){
        try{
          const s = await getDoc(doc(db,'last-redeem','time'));
          const t = s.exists() && s.data().ts?.toDate ? s.data().ts.toDate() : null;
          if (!t){ sinceTxt.textContent='å°šæœªå…Œç¾'; return; }
          function tick(){
            const diff = Date.now() - t.getTime();
            const days = Math.floor(diff/86400000);
            const hh = String(Math.floor(diff%86400000/3600000)).padStart(2,'0');
            const mm = String(Math.floor(diff%3600000/60000)).padStart(2,'0');
            const ss = String(Math.floor(diff%60000/1000)).padStart(2,'0');
            sinceTxt.textContent = `${days} å¤© ${hh}:${mm}:${ss}`;
          }
          tick(); clearInterval(loadSince._timer); loadSince._timer = setInterval(tick,1000);
        }catch{ sinceTxt.textContent='è®€å–å¤±æ•—'; }
      }

      /* ç´¯è¨ˆï¼ˆå…¨éƒ¨æœŸé–“ï¼‰ */
      const sumThink=document.getElementById('sumThink');
      const sumHug=document.getElementById('sumHug');
      const sumKiss=document.getElementById('sumKiss');
      const sumLean=document.getElementById('sumLean');
      const sumRub=document.getElementById('sumRub');
      const sumTap=document.getElementById('sumTap');
      async function loadSumAll(){
        const snap = await getDocs(query(collection(db,'redeems'), orderBy('ts','desc')));
        let T=0,H=0,K=0,L=0,R=0,TP=0;
        snap.forEach(d=>{ const x=d.data()||{}; T+=x.think||0; H+=x.hug||0; K+=x.kiss||0; L+=x.lean||0; R+=x.rub||0; TP+=x.tap||0; });
        sumThink.textContent=T; sumHug.textContent=H; sumKiss.textContent=K; sumLean.textContent=L; sumRub.textContent=R; sumTap.textContent=TP;
      }

      /* çµ±è¨ˆè¡¨ï¼ˆå¹´/æœˆï¼‰ */
      const selYear = document.getElementById('selYear');
      const selMonth= document.getElementById('selMonth');
      const tbStats = document.getElementById('tbStats');
      const sumPThink=document.getElementById('sumPThink');
      const sumPHug=document.getElementById('sumPHug');
      const sumPKiss=document.getElementById('sumPKiss');
      const sumPLean=document.getElementById('sumPLean');
      const sumPRub=document.getElementById('sumPRub');
      const sumPTap=document.getElementById('sumPTap');

      async function loadStatsTable(){
        tbStats.innerHTML = `<tr><td colspan="8" class="muted">è®€å–ä¸­â€¦</td></tr>`;
        const yVal = selYear.value, mVal = selMonth.value;
        const qy = query(collection(db,'redeems'), orderBy('date','asc'));
        const snap = await getDocs(qy);
        const rows = []; let sT=0,sH=0,sK=0,sL=0,sR=0,sTP=0;
        snap.forEach(ds=>{
          const d = ds.data()||{}; if (!d.date) return;
          if (yVal && !d.date.startsWith(yVal)) return;
          if (mVal && d.date.slice(5,7)!==mVal) return;
          rows.push(`<tr><td>${d.date}</td><td>${d.think||0}</td><td>${d.hug||0}</td><td>${d.kiss||0}</td><td>${d.lean||0}</td><td>${d.rub||0}</td><td>${d.tap||0}</td><td>${(d.tapTarget||'').toUpperCase()}</td></tr>`);
          sT+=d.think||0; sH+=d.hug||0; sK+=d.kiss||0; sL+=d.lean||0; sR+=d.rub||0; sTP+=d.tap||0;
        });
        tbStats.innerHTML = rows.length ? rows.join('') : `<tr><td colspan="8" class="muted">æœ¬æœŸé–“æ²’æœ‰è³‡æ–™</td></tr>`;
        sumPThink.textContent=sT; sumPHug.textContent=sH; sumPKiss.textContent=sK; sumPLean.textContent=sL; sumPRub.textContent=sR; sumPTap.textContent=sTP;
      }
      (async function initYearMonth(){
        const snap = await getDocs(query(collection(db,'redeems'), orderBy('date','asc')));
        const years = new Set(); const months = new Set([""]);
        snap.forEach(d=>{ const s=(d.data()?.date||""); if (s.length>=7){ years.add(s.slice(0,4)); months.add(s.slice(5,7)); } });
        selYear.innerHTML = `<option value="">å…¨éƒ¨</option>` + Array.from(years).sort().map(y=>`<option value="${y}">${y}</option>`).join('');
        selMonth.innerHTML = `<option value="">å…¨éƒ¨</option>` + Array.from(months).filter(Boolean).sort().map(m=>`<option value="${m}">${m}</option>`).join('');
        selYear.onchange=loadStatsTable; selMonth.onchange=loadStatsTable;
        loadStatsTable();
      })();

      /* ===== åŒ¯å‡º CSVï¼ˆå…Œç¾ã€ç•™è¨€ï¼‰ & æ‰“åŒ… ZIP ===== */
      function csvEscape(s){ const t=String(s??''); return /[",\r\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t; }
      function fmtDT(d){
        const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0');
        const hh=String(d.getHours()).padStart(2,'0'), mm=String(d.getMinutes()).padStart(2,'0'), ss=String(d.getSeconds()).padStart(2,'0');
        return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
      }

      async function exportCsvCurrentRange(){
        const yVal = selYear.value, mVal = selMonth.value;
        const snap = await getDocs(query(collection(db,'redeems'), orderBy('date','asc')));
        const rows=[]; let sT=0,sH=0,sK=0,sL=0,sR=0,sTP=0;
        snap.forEach(ds=>{
          const d=ds.data()||{}; if(!d.date) return;
          if (yVal && !d.date.startsWith(yVal)) return;
          if (mVal && d.date.slice(5,7)!==mVal) return;
          rows.push([d.date, d.think||0, d.hug||0, d.kiss||0, d.lean||0, d.rub||0, d.tap||0, (d.tapTarget||'').toUpperCase(), d.story||'']);
          sT+=(d.think||0); sH+=(d.hug||0); sK+=(d.kiss||0); sL+=(d.lean||0); sR+=(d.rub||0); sTP+=(d.tap||0);
        });
        if(!rows.length){ alert('æœ¬æœŸé–“æ²’æœ‰è³‡æ–™å¯åŒ¯å‡º'); return; }
        const header=['æ—¥æœŸ','æƒ³ä½ ','æŠ±æŠ±','è¦ªè¦ª','é ä¸€ä¸‹','æ“æ“','æ‰“æ‰“(æ‰£)','æ‰£åˆ°','å°æ•…äº‹'];
        const lines=[ header.map(csvEscape).join(',') ];
        for(const r of rows) lines.push(r.map(csvEscape).join(','));
        lines.push(['åˆè¨ˆ',sT,sH,sK,sL,sR,sTP,'',''].map(csvEscape).join(','));
        const csv = '\uFEFF' + lines.join('\r\n');
        const now = new Date();
        const ym = yVal ? (mVal ? `${yVal}-${mVal}` : yVal) : 'å…¨éƒ¨';
        const fname = `redeems-${ym}-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}.csv`;
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'}), url = URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url; a.download=fname; document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
      }
      document.getElementById('btnExportCsv')?.addEventListener('click', exportCsvCurrentRange);

      async function exportNotesCsvCurrentRange(){
        const yVal = selYear.value, mVal = selMonth.value;
        const snap = await getDocs(query(collection(db,'notes'), orderBy('ts','asc')));
        const header=['æ—¥æœŸæ™‚é–“','å§“å','ç•™è¨€å…§å®¹'];
        const lines=[ header.map(csvEscape).join(',') ];
        let count=0;
        snap.forEach(ds=>{
          const d=ds.data()||{}; const dt=d.ts?.toDate?.(); if(!dt) return;
          const y=String(dt.getFullYear()), m=String(dt.getMonth()+1).padStart(2,'0');
          if (yVal && y!==yVal) return;
          if (mVal && m!==mVal) return;
          lines.push([ fmtDT(dt), d.name||'', d.story||'' ].map(csvEscape).join(','));
          count++;
        });
        if (count===0){ alert('æœ¬æœŸé–“æ²’æœ‰ç•™è¨€å¯åŒ¯å‡º'); return; }
        lines.push(['ç¸½ç­†æ•¸', count, ''].map(csvEscape).join(','));
        const csv = '\uFEFF' + lines.join('\r\n');
        const now = new Date();
        const ym = yVal ? (mVal ? `${yVal}-${mVal}` : yVal) : 'å…¨éƒ¨';
        const fname = `notes-${ym}-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}.csv`;
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'}), url = URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url; a.download=fname; document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
      }
      document.getElementById('btnExportNotesCsv')?.addEventListener('click', exportNotesCsvCurrentRange);

      // ===== æ‰“åŒ… ZIPï¼ˆå…Œç¾ CSV + ç•™è¨€ CSV + meta.jsonï¼‰ =====
      async function buildRedeemsCsv(yVal, mVal){
        const snap = await getDocs(query(collection(db,'redeems'), orderBy('date','asc')));
        const header=['æ—¥æœŸ','æƒ³ä½ ','æŠ±æŠ±','è¦ªè¦ª','é ä¸€ä¸‹','æ“æ“','æ‰“æ‰“(æ‰£)','æ‰£åˆ°','å°æ•…äº‹'];
        const lines=[ header.map(csvEscape).join(',') ];
        let sT=0,sH=0,sK=0,sL=0,sR=0,sTP=0;
        snap.forEach(ds=>{
          const d=ds.data()||{}; if(!d.date) return;
          if (yVal && !d.date.startsWith(yVal)) return;
          if (mVal && d.date.slice(5,7)!==mVal) return;
          lines.push([d.date, d.think||0, d.hug||0, d.kiss||0, d.lean||0, d.rub||0, d.tap||0, (d.tapTarget||'').toUpperCase(), d.story||''].map(csvEscape).join(','));
          sT+=d.think||0; sH+=d.hug||0; sK+=d.kiss||0; sL+=d.lean||0; sR+=d.rub||0; sTP+=d.tap||0;
        });
        if (lines.length===1) return null;
        lines.push(['åˆè¨ˆ', sT, sH, sK, sL, sR, sTP, '', ''].map(csvEscape).join(','));
        return '\uFEFF' + lines.join('\r\n');
      }
      async function buildNotesCsv(yVal, mVal){
        const snap = await getDocs(query(collection(db,'notes'), orderBy('ts','asc')));
        const header=['æ—¥æœŸæ™‚é–“','å§“å','ç•™è¨€å…§å®¹'];
        const lines=[ header.map(csvEscape).join(',') ];
        let count=0;
        snap.forEach(ds=>{
          const d=ds.data()||{}; const dt=d.ts?.toDate?.(); if(!dt) return;
          const y=String(dt.getFullYear()), m=String(dt.getMonth()+1).padStart(2,'0');
          if (yVal && y!==yVal) return;
          if (mVal && m!==mVal) return;
          lines.push([ fmtDT(dt), d.name||'', d.story||'' ].map(csvEscape).join(','));
          count++;
        });
        if (count===0) return null;
        lines.push(['ç¸½ç­†æ•¸', count, ''].map(csvEscape).join(','));
        return '\uFEFF' + lines.join('\r\n');
      }
      function buildMetaJson(){
        const theme = document.documentElement.getAttribute('data-theme') || 'light';
        const colorPrefs = (()=>{ try{ return JSON.parse(localStorage.getItem('colorPrefs')||'{}'); }catch{ return {}; }})();
        const counts = (typeof lastCounts==='object' && lastCounts) ? lastCounts : {};
        const exportedAt = new Date().toISOString();
        return JSON.stringify({ theme, colorPrefs, counts, exportedAt }, null, 2);
      }
      let __zipReady = null;
      function loadJSZip(){
        if (__zipReady) return __zipReady;
        __zipReady = new Promise((resolve, reject)=>{
          if (window.JSZip) return resolve(window.JSZip);
          const s=document.createElement('script');
          s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
          s.onload=()=> resolve(window.JSZip);
          s.onerror=()=> reject(new Error('JSZip è¼‰å…¥å¤±æ•—'));
          document.head.appendChild(s);
        });
        return __zipReady;
      }
      async function exportZipAll(){
        try{
          const yVal = selYear.value;
          const mVal = selMonth.value;
          const ymLabel = yVal ? (mVal ? `${yVal}-${mVal}` : yVal) : 'å…¨éƒ¨';
          const [redeemsCsv, notesCsv] = await Promise.all([
            buildRedeemsCsv(yVal, mVal),
            buildNotesCsv(yVal, mVal)
          ]);
          if (!redeemsCsv && !notesCsv){
            alert('æœ¬æœŸé–“æ²’æœ‰ä»»ä½•è³‡æ–™å¯åŒ¯å‡º');
            return;
          }
          const meta = buildMetaJson();
          const JSZip = await loadJSZip();
          const zip = new JSZip();
          if (redeemsCsv) zip.file(`redeems-${ymLabel}.csv`, redeemsCsv);
          if (notesCsv)   zip.file(`notes-${ymLabel}.csv`, notesCsv);
          zip.file('meta.json', meta);
          const blob = await zip.generateAsync({ type:'blob' });
          const now = new Date();
          const fname = `tallywall-${ymLabel}-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}.zip`;
          const url = URL.createObjectURL(blob);
          const a=document.createElement('a'); a.href=url; a.download=fname; document.body.appendChild(a); a.click();
          setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
        }catch(err){ showErrorOverlay(err); }
      }
      document.getElementById('btnExportZip')?.addEventListener('click', exportZipAll);

      /* è¿‘æœŸå…Œç¾å°æ•…äº‹ï¼ˆæ’åºï¼‹å»é‡ï¼‰ */
      const storiesList = document.getElementById('storiesList');
      const btnMoreStories = document.getElementById('btnMoreStories');
      const selStorySort = document.getElementById('selStorySort');
      let storiesCursor = null; let storiesBuffer = []; let storiesSeen = new Set();
      function storyRowHTML(d){
        const t = d.ts?.toDate?.()||new Date();
        const dt = `${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,'0')}-${String(t.getDate()).padStart(2,'0')} ${String(t.getHours()).padStart(2,'0')}:${String(t.getMinutes()).padStart(2,'0')}`;
        const safe = (d.story||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        const think = d.think||0, hug=d.hug||0, kiss=d.kiss||0, lean=d.lean||0, rub=d.rub||0, tap=d.tap||0;
        const target = (d.tapTarget||'').toUpperCase();
        return `<div style="margin:8px 0;padding:6px 8px;border:1px solid var(--br);border-radius:10px;background:var(--card)">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
            <strong>${dt}</strong>
            <span>
              <span class="badge think">æƒ³ä½  ${think}</span>
              <span class="badge hug">æŠ±æŠ± ${hug}</span>
              <span class="badge kiss">è¦ªè¦ª ${kiss}</span>
              <span class="badge lean">é ä¸€ä¸‹ ${lean}</span>
              <span class="badge rub">æ“æ“ ${rub}</span>
              <span class="badge tap">æ‰“æ‰“æ‰£ ${tap}${target?` â†’ ${target}`:''}</span>
            </span>
          </div>${safe ? `<div style="margin-top:6px">${safe}</div>` : ``}
        </div>`;
      }
      function applyStorySort(arr, mode){
        const a=[...arr];
        if (mode==='ts_asc') a.sort((x,y)=> (x.ts?.toMillis?.()||0) - (y.ts?.toMillis?.()||0));
        else if (mode==='total_desc') a.sort((x,y)=> ((y.think||0)+(y.hug||0)+(y.kiss||0)+(y.lean||0)+(y.rub||0)) - ((x.think||0)+(x.hug||0)+(x.kiss||0)+(x.lean||0)+(x.rub||0)));
        else if (mode==='rub_desc') a.sort((x,y)=> (y.rub||0) - (x.rub||0));
        else a.sort((x,y)=> (y.ts?.toMillis?.()||0) - (x.ts?.toMillis?.()||0)); // ts_desc
        return a;
      }
      async function loadStories(reset=false){
        if (reset){ storiesCursor=null; storiesBuffer=[]; storiesSeen.clear(); storiesList.innerHTML=''; }
        let qy = query(collection(db,'redeems'), orderBy('ts','desc'), limit(20));
        if (storiesCursor){ qy = query(collection(db,'redeems'), orderBy('ts','desc'), startAfter(storiesCursor), limit(20)); }
        const snap = await getDocs(qy);
        if (snap.empty && !storiesCursor){ storiesList.innerHTML = `<div class="muted">å°šç„¡ç´€éŒ„</div>`; return; }
        let last=null;
        snap.forEach(ds=>{
          const id = ds.id;
          if (storiesSeen.has(id)) return;
          const data = ds.data()||{}; data.__id=id;
          storiesBuffer.push(data); storiesSeen.add(id); last = ds;
        });
        if (last) storiesCursor = last;
        storiesList.innerHTML = applyStorySort(storiesBuffer, selStorySort?.value || 'ts_desc').map(storyRowHTML).join('');
      }
      btnMoreStories.onclick = ()=> loadStories(false);
      selStorySort?.addEventListener('change', ()=> loadStories(true));

      /* é¡è‰²å®¢è£½ */
      document.getElementById('btnColorCfg').addEventListener('click', ()=>{
        const cur = { think: cssVar('--c-think'), hug: cssVar('--c-hug'), kiss: cssVar('--c-kiss'), lean: cssVar('--c-lean'), rub: cssVar('--c-rub'), tap: cssVar('--c-tap') };
        const html = `<div style="font-weight:800;margin-bottom:8px">é¡è‰²è¨­å®š</div>
          <div class="toolbar" style="flex-direction:column;gap:10px">
            <label>æƒ³ä½  <input id="colThink" type="color" value="${tinyHex(cur.think)}"></label>
            <label>æŠ±æŠ± <input id="colHug"   type="color" value="${tinyHex(cur.hug)}"></label>
            <label>è¦ªè¦ª <input id="colKiss"  type="color" value="${tinyHex(cur.kiss)}"></label>
            <label>é ä¸€ä¸‹ <input id="colLean" type="color" value="${tinyHex(cur.lean)}"></label>
            <label>æ“æ“ <input id="colRub"   type="color" value="${tinyHex(cur.rub)}"></label>
            <label>æ‰“æ‰“(æ‰£) <input id="colTap"   type="color" value="${tinyHex(cur.tap)}"></label>
          </div>
          <div class="toolbar" style="margin-top:10px;justify-content:flex-end">
            <button id="btnColorSave">å„²å­˜</button>
            <button id="btnColorCancel">å–æ¶ˆ</button>
          </div>`;
        const dlg = showDialog(html, (d)=>{
          d.querySelector('#btnColorCancel').onclick = ()=> closeDialog(d);
          d.querySelector('#btnColorSave').onclick = ()=>{
            const vals = {
              '--c-think': d.querySelector('#colThink').value,
              '--c-hug':   d.querySelector('#colHug').value,
              '--c-kiss':  d.querySelector('#colKiss').value,
              '--c-lean':  d.querySelector('#colLean').value,
              '--c-rub':   d.querySelector('#colRub').value,
              '--c-tap':   d.querySelector('#colTap').value
            };
            const curr = JSON.parse(localStorage.getItem('colorPrefs')||'{}');
            localStorage.setItem('colorPrefs', JSON.stringify({...curr, ...vals}));
            for(const [k,v] of Object.entries(vals)){ setCssVar(k, v); }
            COLORS = readColors(); drawAll(lastCounts);
            storiesList.innerHTML = applyStorySort(storiesBuffer, document.getElementById('selStorySort').value).map(storyRowHTML).join('');
            closeDialog(d);
          };
        });
      });
      (function loadColorPrefs(){
        try{
          const raw = localStorage.getItem('colorPrefs'); if(!raw) return;
          const obj = JSON.parse(raw)||{}; for(const [k,v] of Object.entries(obj)){ setCssVar(k, v); }
          COLORS = readColors(); drawAll(lastCounts);
        }catch{}
      })();

      /* åªæ˜¯å–®ç¨ç•™è¨€ï¼ˆå§“åï¼‹å…§å®¹ï¼‰ */
      const notesList = document.getElementById('notesList');
      const btnMoreNotes = document.getElementById('btnMoreNotes');
      let notesCursor = null; let notesSeen = new Set();

      (function setupNotesPost(){
        const btnPostNoteOpen = document.getElementById('btnPostNoteOpen');
        if (!btnPostNoteOpen){ console.warn('#btnPostNoteOpen æ‰¾ä¸åˆ°'); return; }

        function closeDialog(dlg){ if(!dlg) return; if (typeof dlg.close==='function'){ try{ dlg.close(); }catch{} } dlg.remove(); }
        function toast(msg){
          const t=document.createElement('div');
          t.textContent=msg; t.style.position='fixed'; t.style.left='50%'; t.style.top='16px'; t.style.transform='translateX(-50%)';
          t.style.padding='8px 12px'; t.style.background='var(--card)'; t.style.color='var(--fg)';
          t.style.border='1px solid var(--br)'; t.style.borderRadius='10px'; t.style.zIndex='9999';
          document.body.appendChild(t); setTimeout(()=> t.remove(), 1600);
        }

        async function submitNote(name, story, dlg){
          try{
            await addDoc(collection(db,'notes'), { name: (name||'').trim(), story: (story||'').trim(), ts: serverTimestamp() });
            if (dlg) closeDialog(dlg);
            loadNotes(true);
            toast('ç•™è¨€å·²é€å‡ºï¼');
          }catch(err){
            showErrorOverlay(err);
            if (dlg){ const btn=dlg.querySelector('#btnPostNoteConfirm'); if(btn){ btn.disabled=false; btn.textContent='é€å‡º'; } }
          }
        }

        function openNoteDialog(){
          const supportsDialog = (typeof HTMLDialogElement !== 'undefined');
          if (!supportsDialog) {
            const name = window.prompt('ä½ çš„åå­—ï¼ˆå¯ç•™ç©ºï¼‰') || '';
            const text = window.prompt('å¯«é»æƒ³èªªçš„è©±å§ï¼ˆä¸å½±éŸ¿è¨ˆæ•¸ï¼‰');
            if (text && text.trim()) submitNote(name, text);
            return;
          }
          const html = `<div style="font-weight:800;margin-bottom:8px">åªæ˜¯å–®ç¨ç•™è¨€</div>
            <label>å§“åï¼ˆå¯ç•™ç©ºï¼‰
              <input id="noteName" type="text" placeholder="ä¾‹å¦‚ Karen / æˆ‘">
            </label>
            <label style="margin-top:8px">å°æ•…äº‹ / ç•™è¨€
              <textarea id="noteStory" rows="4" placeholder="å¯«é»ä»€éº¼çµ¦å½¼æ­¤å§ï½ä¸æœƒå½±éŸ¿è¨ˆæ•¸æˆ–å…Œç¾"></textarea>
            </label>
            <div class="toolbar" style="margin-top:10px;justify-content:flex-end">
              <button id="btnPostNoteConfirm">é€å‡º</button>
              <button id="btnPostNoteCancel">å–æ¶ˆ</button>
            </div>`;
          const dlg = document.createElement('dialog');
          dlg.style.background='var(--card)'; dlg.style.color='var(--fg)';
          dlg.style.border='1px solid var(--br)'; dlg.style.borderRadius='12px';
          dlg.style.padding='14px'; dlg.innerHTML = html;
          document.body.appendChild(dlg);
          try{ dlg.showModal(); }catch{ dlg.setAttribute('open','open'); }
          const $ = sel => dlg.querySelector(sel);
          $('#btnPostNoteCancel').onclick = ()=> closeDialog(dlg);
          $('#btnPostNoteConfirm').onclick = ()=>{
            const name = ($('#noteName').value||'').trim();
            const story = ($('#noteStory').value||'').trim();
            if (!story){ alert('è«‹å…ˆå¯«é»å…§å®¹å–”ï½'); return; }
            $('#btnPostNoteConfirm').disabled = true; $('#btnPostNoteConfirm').textContent='é€å‡ºä¸­â€¦';
            submitNote(name, story, dlg);
          };
          setTimeout(()=> $('#noteStory')?.focus(), 0);
        }

        btnPostNoteOpen.replaceWith(btnPostNoteOpen.cloneNode(true));
        document.getElementById('btnPostNoteOpen').addEventListener('click', openNoteDialog);
      })();

      async function loadNotes(reset=false){
        if (reset){ notesCursor=null; notesSeen.clear(); notesList.innerHTML=''; }
        let qy = query(collection(db,'notes'), orderBy('ts','desc'), limit(20));
        if (notesCursor){ qy = query(collection(db,'notes'), orderBy('ts','desc'), startAfter(notesCursor), limit(20)); }
        const snap = await getDocs(qy);
        if (snap.empty && !notesCursor){ notesList.innerHTML = `<div class="muted">å°šç„¡ç•™è¨€</div>`; return; }
        let last=null; const html=[];
        snap.forEach(ds=>{
          const id = ds.id; if (notesSeen.has(id)) return;
          notesSeen.add(id);
          const d = ds.data()||{};
          const t = d.ts?.toDate?.()||new Date();
          const dt = `${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,'0')}-${String(t.getDate()).padStart(2,'0')} ${String(t.getHours()).padStart(2,'0')}:${String(t.getMinutes()).padStart(2,'0')}`;
          const name = (d.name||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
          const story = (d.story||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
          html.push(`<div style="margin:6px 0">
            <strong>${dt}</strong>${name?` <span class="muted">ãƒ»${name}</span>`:''}<br>${story}
          </div>`);
          last = ds;
        });
        if (last) notesCursor = last;
        notesList.insertAdjacentHTML('beforeend', html.join(''));
      }
      document.getElementById('btnMoreNotes').onclick = ()=> loadNotes(false);

      /* å•Ÿå‹• */
      await ensureCountsDoc();
      loadSince(); loadSumAll(); loadStatsTable(); loadStories(true); loadNotes(true);

    }catch(err){
      showErrorOverlay('Firebase è¼‰å…¥å¤±æ•—ï¼š' + (err && (err.message||err)));
    }
  };

  // ä¸» App å®šç¾©å®Œæˆå¾Œï¼šè‹¥å…ˆå‰å·²é€šéè§£é–ï¼ˆæˆ– TTL å…§ï¼‰ï¼Œç«‹åˆ»åˆå§‹åŒ–ä¸€æ¬¡
  if (localStorage.getItem('app-should-init') === '1') {
    try { window.__afterUnlock(); } finally { localStorage.removeItem('app-should-init'); }
  }
</script>

</body>
</html>

